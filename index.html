<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Phantom + RPC Diagnostic</title>
<style>
  body{font-family:system-ui,-apple-system,Roboto,Arial;background:#071026;color:#e6eef8;padding:18px}
  button{padding:12px 16px;border-radius:10px;background:#60a5fa;border:0;color:#022;font-weight:700}
  pre{background:#021026;padding:12px;border-radius:8px;white-space:pre-wrap;max-height:60vh;overflow:auto}
  .muted{color:#9ab0c8}
</style>
</head>
<body>
  <h2>Automated Phantom + RPC Diagnostic</h2>
  <div class="muted">Opens provider if possible, queries RPC, and tests signing APIs (0‑lamport). Paste full report if anything fails.</div>
  <div style="margin-top:12px">
    <label>RPC to test: <input id="rpc" value="https://api.mainnet-beta.solana.com" style="width:56%"/></label>
  </div>
  <div style="margin-top:12px">
    <button id="run">RUN DIAGNOSTICS</button>
  </div>
  <h3 style="margin-top:12px">Report</h3>
  <pre id="out">Ready. Click RUN DIAGNOSTICS.</pre>

<script src="https://unpkg.com/@solana/web3.js@1.76.0/lib/index.iife.min.js"></script>
<script>
(async function(){
  const out = document.getElementById('out');
  const run = document.getElementById('run');
  const rpcInput = document.getElementById('rpc');

  function log(...args){
    const ts = new Date().toISOString();
    out.textContent += `\n[${ts}] ` + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
    console.log(...args);
  }

  function clear(){ out.textContent = ''; }

  async function waitForProvider(timeout=5000){
    if(window.solana && window.solana.isPhantom) return window.solana;
    return new Promise(resolve=>{
      let done=false;
      const t = setInterval(()=>{
        if(window.solana && window.solana.isPhantom){ clearInterval(t); done=true; resolve(window.solana); }
      },200);
      setTimeout(()=>{ if(!done){ clearInterval(t); resolve(null); } }, timeout);
    });
  }

  async function runDiagnostics(){
    clear();
    log('Starting diagnostics');
    const RPC = rpcInput.value.trim() || 'https://api.mainnet-beta.solana.com';
    log('RPC used', RPC);

    // solanaWeb3 presence
    log('solanaWeb3 present?', typeof solanaWeb3 !== 'undefined');
    log('web3 version object keys', Object.keys(solanaWeb3 || {}));

    // provider detection
    const provider = await waitForProvider(6000);
    log('window.solana present?', !!window.solana);
    log('isPhantom?', provider ? !!provider.isPhantom : false);
    if(!provider){
      log('PROVIDER MISSING: Phantom not injected. If on mobile, open this page inside Phantom in-app browser or use deep-link.');
    } else {
      log('provider object keys', Object.keys(provider));
    }

    // Try trusted connect
    if(provider){
      try {
        const resp = await provider.connect({ onlyIfTrusted: true });
        log('trusted connect response', resp && resp.publicKey ? resp.publicKey.toString() : resp);
      } catch(e){
        log('trusted connect error', e && e.message ? e.message : e);
      }
      // explicit connect (user must confirm if prompted)
      try {
        log('Attempting explicit connect (wallet may prompt) - please approve in wallet if asked');
        const resp2 = await provider.connect();
        log('explicit connect response', resp2 && resp2.publicKey ? resp2.publicKey.toString() : resp2);
      } catch(e){
        log('explicit connect error', e && e.message ? e.message : e);
      }
    }

    // Test RPC queries
    try {
      const conn = new solanaWeb3.Connection(RPC,'confirmed');
      log('Connection created');
      if(provider && provider.publicKey) log('Connected publicKey (provider.publicKey)', provider.publicKey.toString());
      // test getBalance
      const pk = (provider && provider.publicKey) ? new solanaWeb3.PublicKey(provider.publicKey.toString()) : null;
      if(pk){
        try {
          const bal = await conn.getBalance(pk);
          log('getBalance OK, lamports', bal, 'SOL', (bal/solanaWeb3.LAMPORTS_PER_SOL));
        } catch(e){
          log('getBalance failed', e && e.message ? e.message : e);
        }
      } else {
        log('No public key available for getBalance test');
      }
      // test getParsedTokenAccountsByOwner (only if pk)
      if(pk){
        try {
          const parsed = await conn.getParsedTokenAccountsByOwner(pk, { programId: solanaWeb3.TokenInstructions ? solanaWeb3.TokenInstructions.TOKEN_PROGRAM_ID : solanaWeb3.TOKEN_PROGRAM_ID });
          log('getParsedTokenAccountsByOwner OK count', parsed?.value?.length ?? 0);
          if(parsed?.value?.length) log('sample token account', parsed.value[0].pubkey);
        } catch(e){
          log('getParsedTokenAccountsByOwner failed', e && e.message ? e.message : e);
        }
      }

      // Test batch getMultipleAccountsInfo using a small slice if token accounts present
      if(pk){
        try {
          const parsed = await conn.getParsedTokenAccountsByOwner(pk, { programId: solanaWeb3.TOKEN_PROGRAM_ID });
          const list = parsed.value || [];
          log('token accounts fetched', list.length);
          if(list.length){
            const sample = list.slice(0,3).map(v => new solanaWeb3.PublicKey(v.pubkey));
            try {
              const infos = await conn.getMultipleAccountsInfo(sample);
              log('getMultipleAccountsInfo OK sample length', infos.length);
            } catch(e){
              log('getMultipleAccountsInfo failed', e && e.message ? e.message : e);
            }
          }
        } catch(e){
          log('token accounts fetch failed', e && e.message ? e.message : e);
        }
      }
    } catch(e){
      log('RPC tests overall failed', e && e.message ? e.message : e);
    }

    // Test signTransaction and signAndSendTransaction with 0-lamport tx (will prompt wallet)
    if(provider && provider.publicKey){
      const conn = new solanaWeb3.Connection(RPC,'confirmed');
      const from = new solanaWeb3.PublicKey(provider.publicKey.toString());
      try {
        const tx = new solanaWeb3.Transaction().add(
          solanaWeb3.SystemProgram.transfer({ fromPubkey: from, toPubkey: from, lamports: 0 })
        );
        tx.recentBlockhash = (await conn.getRecentBlockhash()).blockhash;
        tx.feePayer = from;
        log('Requesting provider.signTransaction (may prompt) — DO NOT APPROVE UNLESS YOU INTEND TO SIGN. You can reject to test provider behavior.');
        try {
          const signed = await provider.signTransaction(tx);
          log('signTransaction returned:', !!signed && typeof signed.serialize === 'function');
        } catch(e){
          log('signTransaction failed or rejected', e && e.message ? e.message : e);
        }
      } catch(e){
        log('signTransaction test build failed', e && e.message ? e.message : e);
      }

      // signAndSendTransaction (if supported)
      try {
        if(provider.signAndSendTransaction){
          const tx2 = new solanaWeb3.Transaction().add(
            solanaWeb3.SystemProgram.transfer({ fromPubkey: from, toPubkey: from, lamports: 0 })
          );
          tx2.recentBlockhash = (await conn.getRecentBlockhash()).blockhash;
          tx2.feePayer = from;
          log('Requesting provider.signAndSendTransaction (may prompt) — will not transfer funds (0 lamports). Approve to test, or cancel.');
          try {
            const res = await provider.signAndSendTransaction(tx2);
            log('signAndSendTransaction returned signature:', res && res.signature ? res.signature : res);
          } catch(e){
            log('signAndSendTransaction failed/rejected', e && e.message ? e.message : e);
          }
        } else {
          log('provider.signAndSendTransaction not available on this provider');
        }
      } catch(e){
        log('signAndSendTransaction test build failed', e && e.message ? e.message : e);
      }
    } else {
      log('Provider or provider.publicKey missing; skipping sign tests');
    }

    log('Diagnostics complete');
  }

  run.onclick = () => { runDiagnostics().catch(e => { out.textContent += '\\nERROR: ' + (e && e.message ? e.message : e); console.error(e); }); };
})();
</script>
</body>
</html>
